Example Table:
```
create table image_vote(
  id int auto_increment primary key,
  image_id int,
  vote int,
  username varchar(255),
  month int,
  year int,   
  FOREIGN KEY (image_id) REFERENCES image_info(id)
)DEFAULT CHARACTER SET utf8;
CREATE INDEX image_vote_image_idx on image_vote (image_id);
```

Corresponding Mapping:
```
package com.tralev.server;

import fjorm.AutoGenerated;
import fjorm.Id;
import fjorm.TableName;

/**
 * @author mladen
 */
@TableName(table = "image_vote")
public class ImageVote {
  @Id
  @AutoGenerated
  public int id;

  public int image_id;
  public int vote;
  public String username;
  public int month;
  public int year;

}
```

## Rule no1: no submappings - database objects cannot be contained explicitly ##

m:1 and m:n mappings inside Java Objects are evil and root of many performance problems in existing ORMs for Java. **We don't want to support it.**

## Rule no2: each field from the database shall be public in Java ##

Do you really think that `int getVote()` and `void setVote(int vote)` actually is beneficial? If you change the vote 'imageVote.vote = 1;' you know that the field changed, there is side effect. Getters and setters are frequently just overheard unless you work with special cases. We want you to declare fields as public rather than use getters and setters! It produces clearer code without side effects in normal cases.

## Rule no3: field name from the database has to be the same in Java ##

fjorm requires you to use the same field name in the database as in java. **This is done to prevent confusion**. You shall name fields clear in the database and then fjorm will use that clear name as well. Less confusion. If the database field do not have clear name, rename it, if possible. Otherwise, cope with your database naming decision.